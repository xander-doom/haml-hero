import * as vscode from "vscode";
import { exec } from "child_process";
import { promisify } from "util";
import * as fs from "fs";
import * as path from "path";
import * as os from "os";
import { getConfigPath } from "./config";

const execAsync = promisify(exec);
const readFile = promisify(fs.readFile);
const writeFile = promisify(fs.writeFile);
const unlink = promisify(fs.unlink);
const readdir = promisify(fs.readdir);
const rmdir = promisify(fs.rmdir);

let extensionContext: vscode.ExtensionContext;

export function setExtensionContext(context: vscode.ExtensionContext): void {
  extensionContext = context;
}

export interface HamlLintResult {
  success: boolean;
  output: string;
  formattedContent?: string;
  exitCode?: number;
}

interface HamlLintOptions {
  autoCorrect?: boolean;
  cwd: string;
  configPath: string | null;
  linterPath: string;
  additionalArgs?: string;
}

/**
 * Creates a temp file with the given content and returns the path.
 * Creates the temp file in the project directory so RuboCop can find .rubocop.yml
 */
async function createTempFile(content: string, originalFileName: string, projectDir: string): Promise<string> {
  // Create temp file in project's tmp directory (ignored by Rails .gitignore)
  // and allow RuboCop to find .rubocop.yml via upward search
  const tmpDir = path.join(projectDir, "tmp");
  
  try {
    await vscode.workspace.fs.stat(vscode.Uri.file(tmpDir));
  } catch {
    // Create tmp dir if it doesn't exist
    await vscode.workspace.fs.createDirectory(vscode.Uri.file(tmpDir));
  }
  
  const tempFile = path.join(
    tmpDir,
    `.haml-lint-temp-${Date.now()}-${path.basename(originalFileName)}`
  );
  await writeFile(tempFile, content, "utf8");
  return tempFile;
}

/**
 * Safely deletes a temp file, ignoring errors.
 * Also removes the tmp directory if it becomes empty.
 */
async function cleanupTempFile(filePath: string): Promise<void> {
  try {
    await unlink(filePath);
    
    // Try to remove the tmp directory if it's empty
    const dir = path.dirname(filePath);
    try {
      const files = await readdir(dir);
      if (files.length === 0) {
        await rmdir(dir);
      }
    } catch {
      // Ignore errors checking/removing directory
    }
  } catch {
    // Ignore cleanup errors
  }
}

/**
 * Extracts ignored_cops from a .haml-lint.yml config file content.
 */
function extractIgnoredCops(configContent: string): string[] {
  const cops: string[] = [];
  
  // Find the ignored_cops section under RuboCop linter
  // Handles various indentation levels
  const ignoredCopsMatch = configContent.match(/ignored_cops:\s*\n((?:[ \t]+-[^\n]+\n?)*)/);
  if (ignoredCopsMatch) {
    const listContent = ignoredCopsMatch[1];
    const items = listContent.match(/^[ \t]+-[ \t]*([^\n]+)$/gm);
    if (items) {
      for (const item of items) {
        const copName = item.replace(/^[ \t]+-[ \t]*/, "").trim();
        if (copName) {
          cops.push(copName);
        }
      }
    }
  }
  
  return cops;
}

/**
 * Generates a temporary .haml-lint.yml config for global RuboCop rules.
 * 
 * This config:
 * - Inherits from project config (if exists) to preserve all other settings
 * - Merges ignored_cops from both project config and global VS Code settings
 * 
 * Returns null if no global rules are configured (lets haml-lint auto-find project config).
 */
async function generateGlobalRulesConfig(projectConfigPath: string | null): Promise<string | null> {
  const { disabledRubocopRules } = getHamlLintConfig();
  
  // If no global rules configured, don't generate a config
  // Let haml-lint auto-find the project config
  if (disabledRubocopRules.length === 0) {
    return null;
  }
  
  // Start with global rules from VS Code settings
  const allIgnoredCops = new Set<string>(disabledRubocopRules);
  
  // If there's a project config, read it and merge its ignored_cops
  // (since inherits_from won't merge arrays, we have to do it manually)
  if (projectConfigPath) {
    try {
      const projectConfig = await readFile(projectConfigPath, "utf8");
      const projectCops = extractIgnoredCops(projectConfig);
      for (const cop of projectCops) {
        allIgnoredCops.add(cop);
      }
    } catch {
      // Ignore errors reading project config
    }
  }
  
  // Build the config
  let config = "# Auto-generated by HAML Hero extension\n";
  config += "# Combines project config with global VS Code settings\n\n";
  
  // Inherit from project config (for linter settings, excludes, etc.)
  if (projectConfigPath) {
    config += `inherits_from: "${projectConfigPath}"\n\n`;
  }
  
  // Add merged ignored_cops (overrides inherited ones since arrays don't merge in YAML)
  config += `linters:\n`;
  config += `  RuboCop:\n`;
  config += `    enabled: true\n`;
  config += `    ignored_cops:\n`;
  for (const cop of allIgnoredCops) {
    config += `      - ${cop}\n`;
  }
  
  const tempPath = path.join(
    os.tmpdir(),
    `haml-hero-config-${Date.now()}-${Math.random().toString(36).slice(2)}.yml`
  );
  
  await writeFile(tempPath, config, "utf8");
  return tempPath;
}

/**
 * Public function to trigger diagnostics refresh after settings change.
 * This is a no-op now since configs are generated per-operation,
 * but kept for API compatibility.
 */
export async function regenerateHamlLintConfig(): Promise<void> {
  // No-op - configs are now generated per-operation
  // Callers should refresh diagnostics after calling this
}

/**
 * Runs haml-lint on the given content.
 */
export async function runHamlLint(
  content: string,
  originalFilePath: string,
  options: HamlLintOptions
): Promise<HamlLintResult> {
  const tempFile = await createTempFile(content, originalFilePath, options.cwd);
  
  // Generate config for global rules (only if global rules exist)
  // This merges project config's ignored_cops with global VS Code settings
  const globalRulesConfigPath = await generateGlobalRulesConfig(options.configPath);

  try {
    let command: string;
    
    // Get globally disabled linters from settings
    const { globallyDisabledLinters } = getHamlLintConfig();
    const excludeLinterArg = globallyDisabledLinters.length > 0
      ? `--exclude-linter ${globallyDisabledLinters.join(",")}`
      : "";
    
    const additionalArgs = options.additionalArgs || "";
    
    // Use global rules config if generated, otherwise let haml-lint auto-find project config
    // When running from project directory (cwd), haml-lint will automatically find .haml-lint.yml
    const configArg = globalRulesConfigPath ? `--config "${globalRulesConfigPath}"` : "";
    
    if (options.autoCorrect) {
      const config = vscode.workspace.getConfiguration("hamlHero");
      const formatterMode = config.get<string>("formatterMode", "safe");
      const autoCorrectFlag = formatterMode === "all" ? "--auto-correct-all" : "--auto-correct";
      
      command = `"${options.linterPath}" ${autoCorrectFlag} --auto-correct-only --reporter json ${configArg} ${excludeLinterArg} ${additionalArgs} "${tempFile}"`.trim();
    } else {
      command = `"${options.linterPath}" --reporter json ${configArg} ${excludeLinterArg} ${additionalArgs} "${tempFile}"`.trim();
    }

    try {
      const result = await execAsync(command, { cwd: options.cwd });
      
      if (options.autoCorrect) {
        const formattedContent = await readFile(tempFile, "utf8");
        return { success: true, output: result.stdout || "", formattedContent };
      }
      
      return { success: true, output: result.stdout || "" };
    } catch (error: any) {
      // haml-lint exits non-zero when it finds issues
      if (options.autoCorrect) {
        const formattedContent = await readFile(tempFile, "utf8");
        return { 
          success: true, 
          output: error.stdout || "", 
          formattedContent,
          exitCode: error.code 
        };
      }
      
      if (error.stdout) {
        return { success: true, output: error.stdout, exitCode: error.code };
      }
      
      throw error;
    }
  } finally {
    // Clean up temp files
    await cleanupTempFile(tempFile);
    if (globalRulesConfigPath) {
      await cleanupTempFile(globalRulesConfigPath);
    }
  }
}

/**
 * Gets the workspace folder and cwd for a document.
 */
export function getWorkspaceInfo(document: vscode.TextDocument): { 
  workspaceFolder?: vscode.WorkspaceFolder; 
  cwd?: string 
} {
  const workspaceFolder = vscode.workspace.getWorkspaceFolder(document.uri);
  const cwd = workspaceFolder?.uri.fsPath || vscode.workspace.workspaceFolders?.[0]?.uri.fsPath;
  return { workspaceFolder, cwd };
}

/**
 * Gets the haml-lint configuration from VS Code settings.
 */
export function getHamlLintConfig() {
  const config = vscode.workspace.getConfiguration("hamlHero");
  return {
    linterPath: config.get<string>("linterPath", "haml-lint"),
    enableDiagnostics: config.get<boolean>("enableDiagnostics", true),
    enableFormatting: config.get<boolean>("enableFormatting", true),
    enableAutocorrections: config.get<boolean>("enableAutocorrections", true),
    formatterMode: config.get<string>("formatterMode", "safe"),
    additionalLinterArguments: config.get<string>("additionalLinterArguments", ""),
    additionalFormatterArguments: config.get<string>("additionalFormatterArguments", ""),
    formatInBackground: config.get<boolean>("formatInBackground", true),
    globallyDisabledLinters: config.get<string[]>("globallyDisabledLinters", []),
    disabledRubocopRules: config.get<string[]>("disabledRubocopRules", []),
  };
}

/**
 * Gets the config file path for haml-lint.
 */
export async function getHamlLintConfigPath(
  workspaceFolder?: vscode.WorkspaceFolder
): Promise<string | null> {
  return getConfigPath(extensionContext, workspaceFolder);
}
